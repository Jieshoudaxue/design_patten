1.1 设计模式简介
设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 
毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。
项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，
以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

设计模式四人帮，全拼 Gang of Four。在1994年，由Erich Gamma、Richard Helm、Ralph Johnson 和John Vlissides四人合著出版了一本名为
Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，
该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF。

1.2 设计模式的作用
作用有两个：
第一，设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，
这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。
第二，设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。
学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。

1.3 设计模式分类
设计模式，分为3大类，创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns），共23个。
1.3.1 创建型模式：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。
这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
包括以下模式：
简单工厂模式（Simple Factory Pattern）
工厂方法模式（Factory Method Pattern）
抽象工厂模式（Abstract Factory Pattern）
单例模式（Singleton Pattern）
原型模式（Prototype Pattern）
建造者模式（Builder Pattern）
1.3.2 结构型模式：这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
包括以下模式：
适配器模式（Adapter Pattern）
桥接模式（Bridge Pattern）
过滤器模式（Filter、Criteria Pattern）
组合模式（Composite Pattern）
装饰器模式（Decorator Pattern）
外观模式（Facade Pattern）
享元模式（Flyweight Pattern）
代理模式（Proxy Pattern）
1.3.3 行为型模式：这些设计模式特别关注对象之间的通信。
包括以下模式：
责任链模式（Chain of Responsibility Pattern）
命令模式（Command Pattern）
解释器模式（Interpreter Pattern）
迭代器模式（Iterator Pattern）
中介者模式（Mediator Pattern）
备忘录模式（Memento Pattern）
观察者模式（Observer Pattern）
状态模式（State Pattern）
策略模式（Strategy Pattern）
模板模式（Template Pattern）
访问者模式（Visitor Pattern）

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++下面内容主要来自《大话设计模式》+++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

样例路径（重中之重）：/home/ycao/samba-share/designPatten/designPatten-book

1 简单工厂模式(Simple Factory)
1.1 编程初学者常见的问题，就是碰到问题就直觉地用计算机能够理解的逻辑来描述和表达待解决的问题及具体的求解过程。
    即用计算机的方式思考，写出程序只能满足当下需求，程序不容易维护，扩展和复用。
1.2 好的工程化的程序，应该有四大特性，即可维护（方便修改），可复用（可重复使用），可扩展（方便增加新特性）和灵活性好
1.3 程序要想具有四大特性，需要使用面向对象的封装，继承和多态让程序的耦合度降低，需要使用设计模式让程序灵活。
1.4 工厂就是生产对象的工厂，其隐藏了创建对象的细节；
1.5 该模式样例是简单的计算器：将各种运算符分别封装为类，并继承统一的父类，然后再创建一个专门生产运算符类的工厂。
    当需要添加新的运算符时，很方便，软件可维护性很好！

2 策略模式（Strategy）
1.1 商场促销的方式多种多样，有打折促销，有积分促销，有满减。但无论促销方式是什么，目的都是在原有的价格上计算新的价格。
策略模式就是用来定义并封装一系列算法，这些算法完成相同的工作，但有不同的实现。策略模式提取这些算法的共同点，并对外提供
统一的接口，为客户端封装算法的变化，从而降低算法调用和实现间的耦合。
1.2 策略模式通常与简单工厂模式结合使用，两者的结构也比较像；

3 单一职责原则
3.1 一个类应只承担一个职责!
3.2 如果一个类承担的职责过多，耦合就会过多。当其中一个职责发生变化，势必影响其他职责的实现，从而导致脆弱的设计！
3.3 软件设计的一个主要内容就是发现职责，分离职责。

4 开放-封闭原则
4.1 软件实体（类，函数，模块）对扩展开放，对修改关闭。
4.2 在最初编写代码时，我们很难猜测哪些软件实体会发生变化，因此我们可以假设变化不会发生。但当变化发生时，应立即采取行动，
创建抽象隔离变化。一旦反应迟缓，重构代码的代价就会大幅增加。
4.3 所谓创建抽象，多数是提取抽象接口（父类），然后利用多态实现隔绝变化。因此，抽象是程序员的核武器！

5 依赖倒换原则和里氏代换原则
5.1 依赖倒换原则，原话是抽象不应该依赖细节，细节应该依赖抽象，说人话就是要针对接口编程，而不要针对实现编程。
5.2 里氏代换原则，原话是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别，
说人话就是要求子类必须具有父类申明的所有功能！
举个例子，假设所有鸟都会飞，而企鹅不会飞，所以企鹅不能继承鸟。该原则是依赖倒换原则实现的基础。
5.3 封装，继承和多态是面向对象的技术特征，而面向对象作为一种编程思想，真正的标志是依赖倒换原则，即针对接口针对抽象编程。
如果针对细节针对实现编程，那就是面向过程！

6 装饰器模式（Decorator）
6.1 当已有的类的功能“固定”后，如果需要添加其他的“附加功能”，好的办法不是去修改类的源码，添加新的逻辑，而是使用装饰模式，
将要添加的类的装饰功能单独写成一个装饰类，从而实现为已有功能动态添加新的功能；
6.2 装饰模式实现的核心是，装饰类既继承被装饰类，又拥有被装饰类；换句话说，被装饰类既是装饰类的父类，又是装饰类的成员；
6.3 由于装饰类继承被装饰类，因此装饰类与被装饰类具有完全相同的接口，其使得装饰对客户透明；

7 代理模式（Proxy）
7.1 代理模式的核心有两点，第一是代理类和被代理类继承自同一个接口类，保障两者有相同的接口；第二是代理类中有被代理类的引用；
这里的例子是一个男生（代理类）帮另一个男生（被代理类）给女生送礼物；
7.2 代理模式是常用的结构设计模式，客户通过代理类操作被代理类的对象，其能去掉客户不能看到的内容，添加客户希望添加的功能；

8 工厂方法模式（Factory Method）
8.1 简单工厂模式只对被生产类运用了继承和多态，符合依赖倒换原则和开闭原则；而工厂类的生产方法是写死的，当加入新的被生产类时，
必须修改工厂类源码，即增加switch分支，不符合开闭原则；
8.2 工厂方法模式扩展了简单工厂模式，对工厂类也运用了继承和多态，每个工厂类生产特定的对象，从而使整个代码符合开闭原则；
8.2 工厂方法模式和简单工厂模式解决同一类问题，即一种产品多种类型的生产问题

9 原型模式（Prototype）
9.1 原型模式用一个对象当做原型，并克隆该原型，得到一个新的对象。
9.2 原型模式实现的关键就是实现类的拷贝构造函数，C++会默认提供一个拷贝构造函数，但只支持浅拷贝，如果成员属性中有指针或引用，
就必须手动写出拷贝构造函数，实现深拷贝。但要注意，C++一旦涉及到指针，就要小心内存泄露，一般在构造函数中new，
在析构函数中一定要delete！
9.3 在对象初始化时用等号运算符实现对象拷贝，c++就会调用拷贝构造函数。

10 模板模式（Template）
10.1 模板模式（模板方法模式）通过在父类定义一系列虚函数，将操作步骤，算法骨架固定下来，再通过继承，强制在子类中实现这些具体的步骤，
不同的子类共用相同的骨架而有不同的实现。该模式比较简单，但用处特别多，实现的核心就是虚函数，继承和多态。
10.2 模板模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤；

11 迪米特法则
11.1 迪米特法则，又称最少知道原则。首先，在类的结构设计上，每一个类都应当尽量降低成员的访问权限，尽量避免外部类可以直接读写该类的成员属性。
其次，如果两个类不用直接交互，可以引入第三者实现间接交互，降低耦合（样例是中介者模式）。
11.2 迪米特法则的根本思想是强调类之间的松耦合！

12 外观模式（Facade）
12.1 外观模式主要为子系统提供封装，以便对外提供简洁统一的接口，实现的核心是外观类的方法调用子系统的函数或方法。
12.2 该模式非常简单，连多态和继承都用不到，但用处及其广泛。
12.3 使用外观模式分三种情况，首先是软件设计之初，应有意识地在大的层次和模块之间应用外观模式；其次是开发阶段，随着子系统和子模块
越来越复杂，应有意识地利用外观模式将其分割为更小的模块；最后，如果需要在软件中移植老的复杂代码，建议使用外观模式封装老代码，
降低现有代码和老代码的耦合；
12.4 外观模式使系统更符合迪米特法则；

13 建造者模式（Builder）
13.1 建造者模式主要用于创建一些复杂的对象，这些对象内部的建造顺序通常是稳定的，但建造细节面临着变化；为了隐藏整个构造细节，
建造者模式为此设计了一个指挥类；
13.2 建造者模式的核心就是Director指挥类，其按顺序调用建造类的各个成员函数完成产品创建；

14 观察者模式（Observer）
14.1 观察者模式是应用很广泛的一种设计模式，它解决的是对象间的一种一对多的依赖关系，即当一个对象的状态发生改变时，
所有依赖于它的对象都得到通知并被自动更新。
14.2 典型的例子是博客系统，当一个博主更新了它的博客，所有订阅该博主的订阅者都会收到通知，并执行相关动作，
如查看，收藏等。还有一个例子就是交通信号灯和车，当信号灯改变，所有相关的车都会看到并执行相应的动作，或停车，或启动。
14.3 观察者模式实现的重点有两处，一是通知者内部必须有观察者组成员，一般用list，方便通知观察者；
二是观察者内部必须有通知者成员，方便调用通知者方法，获得通知者消息；
14.4 观察者模式也被称为依赖模式，或发布-订阅模式。

15 抽象工厂模式（Abstract Factory Pattern）
15.1 简单工厂和工厂方法模式用于解决一种产品多种类型的生产问题，抽象工厂模式用于解决多种产品多种类型的生产问题；
15.2 抽象工厂模式类似工厂方法模式，区别在于抽象工厂模式的工厂类有多个接口，一个接口生产一种产品的一种类型，
而工厂方法模式的工厂类只有一个接口；
15.2 C和C++创建结构体对象或类对象，一般采用直接写死的方式；但C#和java提供了一种直接通过结构体名或类名“字符串”
创建结构体变量和类对象的方式，称为“反射”。但C和C++可以通过间接的方式实现反射，C实现反射的样例参考Pishon的表查找，
C++实现反射的样例参考https://www.cnblogs.com/xudong-bupt/p/6643721.html
15.3 抽象工厂模式的工厂类过多，可以采用简单工厂模式简化，再利用反射技术，可以进一步简化掉简单工厂模式的if或switch判断，样例以后补；

16 状态模式（State）
16.2 很多事物包括人都有多种状态，状态的切换依据一个或多个变量，不同的状态有不同的行为。比如水，根据温度不同有冰，水，气三种状态。
16.1 事物根据状态的不同有不同的行为，用代码实现一般采用条件分支。如果状态比较少，这样没有问题，如果状态众多，条件分支就会非常多，
导致代码臃肿，产生坏味道，而且不符合开闭原则；
16.2 状态模式通过把状态的判断逻辑转移到表示不同状态的一系列类中，从而将复杂的判断逻辑简化。
16.3 状态模式实现的核心：事物类内部必须有状态类的引用，并且该引用随着状态值的改变，指向不同的状态类，在此过程中注意不要内存泄露。

17 适配器模式（Adapter）
17.1 适配器模式用于将一个类的接口转换成使用者希望的另一种接口，其使得原来由于接口不兼容而不能一起工作的那些类可以一起工作；
17.2 适配器模式类似外观模式，但是外观模式更适用于为大的模块或者代码写接口，而适配器模式主要用于代码量不那么大的情况，比如一个类。
17.3 适配器模式好用，但不要滥用，只有双方都不太容易更改自己的接口时，再考虑使用适配器模式。
17.4 适配器模式实现的核心：适配器类拥有被适配类的成员，从而方便调用被适配类的方法；

18 备忘录模式（Memento）
18.1 玩游戏时，如果中间退出，系统会保存当前进度，以便再进入时继续玩。浏览网页时，如果中间退出，浏览器会保存阅读位置，以便再进入时继续看。
对应到设计模式，就是备忘录模式，其旨在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
18.2 备忘录模式适用于功能比较复杂的，需要维护和记录属性历史值的类，尤其用于当属性因错误变为无效值时，恢复到初始状态。
18.3 备忘录模式实现的核心：备忘录类作为管理类的成员，记录和恢复均有管理类辅助完成；

19 组合模式（Composite）
19.1 组合模式用于处理整理与部分可以被一致对待的问题，典型的例子是总公司，部门，分公司，分公司部门；
19.2 类似总公司，部分和分公司的例子，还有文件夹，文件和子文件夹，它们均属于分层的带有递归性质的树形结构，
组合模式能将这些对象组合成树形结构，且使客户对单个对象（文件，部门）和组合对象（文件夹，分公司）的使用具有一致性。
19.2 组合模式实现的核心：叶子类（部门类）和组合类（分公司类）继承同一个虚拟父类（公司父类），实现相同的接口；
同时组合类内部拥有虚拟父类的list组，组合类中的方法遍历list组时采用递归调用下一级组合类方法。

20 迭代器模式（Iterator）
20.1 迭代器模式就是为不同的聚集组提供统一的遍历接口，如first，next，isEnd，current等，注意是不同的聚集对象！
20.2 迭代器模式实现的核心是迭代器类必须拥有被迭代类的指针，创建迭代器类时将被迭代类指针传入（初始化），客户调用迭代器类的统一接口完成迭代。
20.3 迭代器模式已经被众多语言在语法上默认支持了，如python foreach in，C++ STL也支持迭代，所以这个模式一般不用人为实现了。

21 单例模式（Singleton）
21.1 保证一个类仅有一个实例，并提供一个获得该实例的全局访问点
21.2 单例模式实现的核心：一是类的构造函数是私有的，防止在类外直接创建成员(即实现静态类)，从而保证这个类只有一个实例；
二是成员instance和获取instance的方法getInstance都是静态成员；
21.3 getInstance为静态成员是因为可以在不创建类对象的情况下直接调用；至于instance，如果其为非静态，
则无法被getInstance调用（类的静态成员方法不能访问普通成员变量）；
21.3 样例实现了线程安全的单例模式，getInstance方法内部实现了双重锁定，这是经典实现，解释见《大话设计模式》P218。

22 合成/聚合复用原则
22.1 软件工程的七大原则相互之间是会起矛盾的；开放-封闭原则，依赖倒换原则和里氏代换原则推动我们采用继承和多态解决问题，
但如果继承用的太多，就会导致出现巨型类和多层继承类，从而违反单一职责原则和开放封闭原则。
22.2 于是，在很多情况下应避免采用继承，而是将负责的类解开为两个或以上的类，再使用合成（一种整体和部分间的“强拥有关系”，比如鸟和翅膀）
和聚合（一种“弱拥有关系”，比如鸟和鸟群）将两个类联系起来，这正是合成/聚合复用原则；
22.3 桥接模式很好的体现了这一原则；

23 桥接模式（bridge）
23.1 当一个系统有多种分类方式，每种分类方式都有多种样式，如手机的品牌和系统，最好的方式就是把它们独立出来各自成类，而两个类之间采用
合成/聚合关系，从而避免出现巨型类和多层继承类，这就是桥接模式。
23.2 桥接模式实现的核心：抽象类（手机品牌类）拥有实现类（手机系统类）的指针，抽象类的方法内部调用实现类的方法执行具体的操作！
23.3 桥接模式符合合成/聚合复用原则，其使得系统更符合单一原则；

24 命令模式（Command）
24.1 当我们按下按钮，火箭发射。按按钮就是一次请求，火箭发射就是响应命令，执行动作。
24.2 在编程中，最简单的请求和响应就是直接调用函数接口。但当系统复杂时，我们通常希望请求和响应分离，分属不同的子模块，
此时再通过直接调用函数实现，将增加模块的耦合度，于是提出了命令模式。
24.3 命令模式将命令请求与命令执行之间解耦，主要用于复杂系统中，管理复杂多样的命令。
命令模式在请求与响应之间，加了一个中间管理类，并将每一个命令封装成一个类，且所有命令类继承相同的父类。
中间管理类负责统一管理所有命令，包括添加命令，撤销命令，发送命令等；请求者只与管理类交互。
24.4 以烤肉店为例，命令模式实现的核心有三点：第一，命令类并不实际执行命令，但拥有烤肉师傅类（具体执行类）指针成员，
从而调用烤肉师傅类方法执行具体的命令；第二，管理类（服务员类）拥有命令类指针数组，对外提供命令管理接口，包括添加命令，撤销命令；
第三，管理类一般提供统一执行命令的方法，而不是每添加一个命令，执行一次；

25 责任链模式（Chain of Responsibility）
25.1 责任链模式主要解决同一种请求，但不同量级，对应不同审批层级的问题，典型如公司员工加薪（加薪幅度），公司员工请假（请假天数）；
25.2 责任链模式实现的核心：抽象管理者类（父类）拥有自己的指针成员变量，每层管理者在初始化时设置自己的上级，当自己无法处理一个请求时，
则调用上级管理者的处理函数处理；一个请求从最低一级管理者开始处理，层层处理，直到请求被处理；

26 中介者模式（Mediator）
26.1 中介者模式很好的诠释了迪米特法则的第二条，主要解决系统内一组定义良好的类间有复杂交互的情况时，如何降低类间耦合度的问题。
中介者模式通过引入第三方中介者类，使得各对象不需要显式地相互调用，从而将网状结构的交互变成星形结构，大大降低了类间耦合；
26.2 中介者模式的缺点在于中介者类集中了大量了交互，变得较为复杂，一旦出问题，系统将崩溃。因此，当系统出现多对多的交互复杂的对象群时，
应先检讨类的定义是否合理，而不是急于使用中介者模式；
26.3 以国家和联合国为例，中介者模式实现的核心：一是抽象国家类拥有联合国类的指针，方便调用联合国类的方法；二是联合国类（中介类）拥有
各个国家的指针，以调用具体国家类的方法；该模式的样例是美国类通过联合国类向伊拉克类传递消息；

27 享元模式（Flyweight）
27.1 一个类理论上可以定义无数个对象。但是真的出现一个类定义很多对象时，内存就会受到很大的压力。比如一个围棋网站，当用户新建一局对弈时，
如果每一手棋都在后台创建一个棋子对象，那么这个网站可能无法承载太多人访问。
27.2 享元模式用于处理大量细粒度对象的内存优化问题。核心的思想是将一个对象的状态分为内部状态和外部状态，内部状态是稳定状态，
外部状态是常变状态，对象只保留内部状态，如围棋的棋子，颜色是内部状态，位置是外部状态，棋子类只有颜色属性；
享元模式将外部状态单独提炼成类，并创建一个工厂类（棋盘）存储外部状态，当使用外部状态时，通过参数传给棋子类。
27.3 以围棋为例，享元模式实现的核心是：棋盘类拥有两种棋子类的指针，并拥有存储两种棋子位置的vector；棋子类的方法接收棋子位置类作为参数；
客户端只与棋盘类交互；
27.4 享元模式的缺点是使程序逻辑变得复杂，因此只有在真的节约了很多内存的情况下，才值得使用！

28 解释器模式（Interpreter）
28.1 如果一种特定类型的问题发生的频率足够高，那么就值得将该问题的各个实例表述为一个简单语言的句子，并构建一个解释器，
该解释器通过解释这些句子来解决问题；
28.2 以抽象语法树为例，解释器模式实现的核心：所有节点均继承自一个抽象节点类，包括终结符和非终结符节点；另外需要实现一个handle类，
其负责管理整个解释器以及构建抽象语法树；详细细节参考样例代码和博客：https://blog.csdn.net/caoshangpa/article/details/52912440；
28.3 解释器模式的典型应用有编译器和正则表达式，但其在实际开发中用的不多，主要原因是实现复杂且不好维护，而且也有可替代的开源库，
因此这个模式重在学习；

29 访问者模式（Visitor）
29.1 访问者模式适用于数据结构相对稳定的系统，其目的是要把对数据的操作与数据本身解耦；
29.2 如果一个系统有比较稳定的数据结构，而又有易于变化的操作算法时，推荐使用访问者模式，因为其最大的优势是很容易增加新的操作；
29.3 访问者模式实现的核心是一个叫双分派的技术，大概的流程是：数据类的accept方法接收访问者类的指针作为参数（第一次分派），
accept方法内部调用访问者类的visit方法，将自己传进去（this指针，第二次分派），真正的访问动作是在访问者类的visit方法做的！
具体请参考本模式样例，有代码注释；样例来自博客：https://www.jianshu.com/p/1f1049d0a0f4；
29.4 访问者模式真正实现了数据和操作解耦！代价是结构复杂，且应用场景很少，因为很少有数据结构恒定不变的情况；
GoF的作者说：大多时候你不需要访问者模式，但当你真的需要时，就是真的需要它了！

